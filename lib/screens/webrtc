import 'dart:convert';
import 'dart:html' as html;
import 'package:flutter_webrtc/flutter_webrtc.dart';

WebSocket socket;
RTCPeerConnection yourConn;
MediaStream stream;
dynamic offer1;
dynamic answer1;

void getType(dynamic data) {
  switch (data['message_type']) {
    case "logina":
      handleLogin(data['data']);
      break;
    case "offera":
      handleOffer(data['data']);
      break;
    case "answera":
      handleAnswer(data['data']);
      break;
    case "candidatea":
      handleCandidate(data['data']);
      break;
    case "leavea":
      handleLeave();
      break;
    default:
      break;
  }
}

void send(dynamic message) {
  if (socket.readyState == WebSocket.OPEN) {
    socket.send(json.encode(message));
  }
}

final localRenderer = RTCVideoRenderer();
final remoteRenderer = RTCVideoRenderer();

void handleLogin() async {
  try {
    final mediaConstraints = {
      'audio': true,
      'video': true,
    };
    final myStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
    stream = myStream;
    localRenderer.srcObject = stream;
    final configuration = {
      "iceServers": [{"urls": "stun:stun2.1.google.com:19302"}]
    };
    yourConn = await createPeerConnection(configuration);
    yourConn.addStream(stream);
    yourConn.onAddStream = (MediaStreamEvent e) {
      remoteRenderer.srcObject = e.stream;
    };
    yourConn.onIceCandidate = (RTCIceCandidateEvent event) {
      if (event.candidate != null) {
        send({
          "message_type": "candidates",
          "data": event.candidate.toMap(),
        });
      }
    };
  } catch (error) {
    print(error);
  }
}

void createOffer() async {
  try {
    final offer = await yourConn.createOffer({'offerToReceiveVideo': 1, 'offerToReceiveAudio': 1});
    offer1 = offer;
    await yourConn.setLocalDescription(offer);
    send({
      "message_type": "offers",
      "data": offer.toMap(),
    });
  } catch (error) {
    print("Error when creating an offer");
  }
}

void handleOffer(Map<String, dynamic> offer) async {
  try {
    await yourConn.setRemoteDescription(RTCSessionDescription(offer['sdp'], offer['type']));
    final answer = await yourConn.createAnswer({'offerToReceiveVideo': 1, 'offerToReceiveAudio': 1});
    answer1 = answer;
    await yourConn.setLocalDescription(answer);
    send({
      "message_type": "answers",
      "data": answer.toMap(),
    });
  } catch (error) {
    print("Error when creating an answer");
  }
}

void handleAnswer(Map<String, dynamic> answer) async {
  await yourConn.setRemoteDescription(RTCSessionDescription(answer['sdp'], answer['type']));
}

void handleCandidate(Map<String, dynamic> candidate) async {
  await yourConn.addCandidate(RTCIceCandidate(candidate['candidate'], candidate['sdpMid'], candidate['sdpMlineIndex']));
}

void handleLeave() {
  remoteRenderer.srcObject = null;
  yourConn.close();
  yourConn.onIceCandidate = null;
  yourConn.onTrack = null;
}

void connect_socket() {
  final token = html.querySelector('#token').value;
  final ws_scheme = window.location.protocol == "https:" ? "wss" : "ws";
  final ws_path = '$ws_scheme://localhost:8000/ws/test/sdfsdf/?token=$token';
  socket = WebSocket(ws_path);
  socket.onMessage.listen((message) {
    final data = json.decode(message.data);
    getType(data);
  });

  handleLogin();
}